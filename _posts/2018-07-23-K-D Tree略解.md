---
layout:     post
title:      "K-D Tree略解"
date:       2018-07-23
author:     "DieSheep"
header-img: "img/used/undertale-31.jpg"
catalog: true
tags:
    - K-D Tree
---
[K-D Tree](https://baike.baidu.com/item/kd-tree/2302515?fr=aladdin)是种非常鬼畜的数据结构...

跟平衡树一样，K-D Tree是一棵二叉树，但是不同的是，K-D Tree的每一层构建左右儿子的指标都不同，于是K-D Tree的画风就十分鬼畜QAQ

先看一道[简单题](https://www.luogu.org/problemnew/show/P4148)：
>N*N的棋盘，要求支持单点修改和区间求和，内存限制20M

这不是树套树裸题吗~~暴力数据结构大法好~~

但是N<=500000，树套树最差情况下需要4000G（噗），空间爆炸

emmmm可以用CDQ分治搞

那要是强制在线就不能搞了

这时候就需要K-D Tree了，每个修改操作可以看成加入一个点，注意每一层要换一个指标，这里指标就是横纵坐标

然后就跟平衡树的加入操作一样了
```
void add(int &k,int x,bool D)//k是当前点编号，x为加入点编号，D为指标，D=0指标为横坐标，否则为纵坐标
{
	if(!k)
	{
		k=x;
		return;
	}
	if(s[x].d[D]<=s[k].d[D]) add(tl,x,D^1);//向左走，注意换指标
	else add(tr,x,D^1);//向右走
	pus(k),look(k,D);//pus即子节点上推，look目前用不到
}
```
举个栗子：现在加入了6个点![](/img/study/k-dTree1.png)，红边连接表示左儿子，蓝边连接表示右儿子，加入顺序是(5,4),(3,7),(9,2),(2,6),(4,3),(12,11)，映射一下就成了这张鬼畜的图

每个节点维护9个值：子树横坐标最大值、最小值，子树纵坐标最大值、最小值，这个节点图中对应的点的横纵坐标，左、右儿子编号和这个范围内的点值和
![](/img/study/k-dTree2.png)

可以看出，每个节点维护的最大最小值相当于维护一个矩形区域，如图：
![](/img/study/k-dTree4.png)

黄颜色部分为每个节点维护区域，当遇到一个查询时，如图，褐色部分为查询区域：
![](/img/study/k-dTree5.png)

从跟开始遍历，如果当前节点维护的矩阵在查询范围内，就返回这个节点维护的点权和，如果完全不在范围内就返回0，如果部分在范围内就继续遍历**两个儿子**

