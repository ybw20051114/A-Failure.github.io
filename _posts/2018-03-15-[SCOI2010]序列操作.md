---
layout:     post
title:      "[SCOI2010]序列操作"
date:       2018-03-15
author:     "DieSheep"
header-img: "img/1516875259585.jpg"
catalog: true
tags:
    - 线段树
---
看题第一眼：区间修改、区间查询

出来吧线段树！

于是我一个下午就这么搭进去了。。。

这个题的细节搞得我快崩溃了。。。

定义线段树：

<strong>sum:这段区间内1的总数</strong>

<strong>Lb:这段区间内连续0的最大长度</strong>

<strong>Lw:这段区间内连续1的最大长度</strong>

<strong>llb:这段区间从左端点连续0的最大长度</strong>

<strong>llw:这段区间从左端点连续1的最大长度</strong>

<strong>rlb:这段区间从右端点连续0的最大长度</strong>

<strong>rlw:这段区间从右端点连续1的最大长度</strong>

<strong>fl:翻转标记</strong>

<strong>lazy:下推标记（记录是否全赋为1或0）</strong>

好乱。。。

可以找出上推关系式：（0表示左儿子，1表示右儿子）

<strong>sum=sum[0]+sum[1]</strong>

<strong>Lb=max{Lb[0],Lb[1],rlb[0]+llb[1]}(Lw同理)</strong>

<strong>if(llb[0]==mid-l+1) llb=llb[0]+llb[1] (llw同理)</strong>

<strong>if(rlb[1]==r-mid) rlb=rlb[1]+rlb[0] (rlw同理)</strong>

然而最恶心的是标记下推

lazy的优先级肯定大于翻转标记（全变为一个数就把翻转结果覆盖了）

所以先判断lazy,如果有lazy,左右儿子的翻转标记都要清空

然后就是慢慢打代码了。。。
```cpp
# include<iostream>
# include<cstdio>
# include<cstring>
# define mid (l+r>>1)
# define tl (k<<1)
# define tr (k<<1|1)
using namespace std;
const int MAX=1e5+1;
struct p{
    int sum,Lw,Lb,llw,rlw,llb,rlb,lazy,fl;
}s[MAX<<2];
int n,m;
int max(int x,int y)
{
    return x>y?x:y;
}
void pus(int l,int r,int k)
{
    s[k].sum=s[tl].sum+s[tr].sum;
    
    s[k].Lb=max(s[tl].Lb,s[tr].Lb);
    s[k].Lw=max(s[tl].Lw,s[tr].Lw);
    
    s[k].llb=s[tl].llb;
    s[k].llw=s[tl].llw;
    if(s[tl].llw==mid-l+1)
    s[k].llw+=s[tr].llw;
    if(s[tl].llb==mid-l+1)
    s[k].llb+=s[tr].llb;
    
    s[k].rlb=s[tr].rlb;
    s[k].rlw=s[tr].rlw;
    if(s[tr].rlw==r-mid)
    s[k].rlw+=s[tl].rlw;
    if(s[tr].rlb==r-mid)
    s[k].rlb+=s[tl].rlb;
    
    s[k].Lw=max(s[k].Lw,s[tl].rlw+s[tr].llw);
    s[k].Lb=max(s[k].Lb,s[tl].rlb+s[tr].llb);
}
void down(int l,int r,int k)
{
    int f=s[k].lazy,fl=s[k].fl,L1=mid-l+1,L2=r-mid;
    s[k].lazy=-1;
    if(!f)
    {
        s[tl]=(p){0,0,L1,0,0,L1,L1,0,0};
        s[tr]=(p){0,0,L2,0,0,L2,L2,0,0};
    }
    else if(f==1)
    {
        s[tl]=(p){L1,L1,0,L1,L1,0,0,1,0};
        s[tr]=(p){L2,L2,0,L2,L2,0,0,1,0};
    }
    if(fl)
    {
        s[k].fl=0;
        int sum=s[tl].sum,Lw=s[tl].Lw,Lb=s[tl].Lb,llw=s[tl].llw,rlw=s[tl].rlw,llb=s[tl].llb,rlb=s[tl].rlb;
        s[tl].sum=L1-sum;
		s[tl].Lw=Lb,s[tl].Lb=Lw;
		s[tl].llw=llb,s[tl].rlw=rlb;
		s[tl].llb=llw,s[tl].rlb=rlw;
		s[tl].fl^=1;
        
        sum=s[tr].sum,Lw=s[tr].Lw,Lb=s[tr].Lb,llw=s[tr].llw,rlw=s[tr].rlw,llb=s[tr].llb,rlb=s[tr].rlb;
        s[tr].sum=L2-sum;
		s[tr].Lw=Lb,s[tr].Lb=Lw;
		s[tr].llw=llb,s[tr].rlw=rlb;
		s[tr].llb=llw,s[tr].rlb=rlw;
		s[tr].fl^=1;
    }
}
void build(int l,int r,int k)
{
    s[k].lazy=-1;
    if(l==r)
    {
        int x;
        scanf("%d",&x);
        s[k]=(p){x,x,(x^1),x,x,(x^1),(x^1),-1,0};
        return;
    }
    build(l,mid,tl);
    build(mid+1,r,tr);
    pus(l,r,k);
}
void change1(int l,int r,int k,int L,int R)
{
    if(l>=L&&r<=R)
    {
        int LL=r-l+1;
        s[k]=(p){0,0,LL,0,0,LL,LL,0,0};
        return;
    }
    if(l>R||r<L) return;
    down(l,r,k);
    change1(l,mid,tl,L,R);
    change1(mid+1,r,tr,L,R);
    pus(l,r,k);
}
void change2(int l,int r,int k,int L,int R)
{
    if(l>=L&&r<=R)
    {
        int LL=r-l+1;
        s[k]=(p){LL,LL,0,LL,LL,0,0,1,0};
        return;
    }
    if(l>R||r<L) return;
    down(l,r,k);
    change2(l,mid,tl,L,R);
    change2(mid+1,r,tr,L,R);
    pus(l,r,k);
}
void change3(int l,int r,int k,int L,int R)
{
    if(l>=L&&r<=R)
    {
        int LL=r-l+1,sum=s[k].sum,Lw=s[k].Lw,Lb=s[k].Lb,llw=s[k].llw,rlw=s[k].rlw,llb=s[k].llb,rlb=s[k].rlb;
        s[k]=(p){LL-sum,Lb,Lw,llb,rlb,llw,rlw,s[k].lazy,(s[k].fl^1)};
        return;
    }
    if(l>R||r<L) return;
    down(l,r,k);
    change3(l,mid,tl,L,R);
    change3(mid+1,r,tr,L,R);
    pus(l,r,k);
}
int ask1(int l,int r,int k,int L,int R)
{
    if(l>=L&&r<=R) return s[k].sum;
    if(l>R||r<L) return 0;
    down(l,r,k);
    return ask1(l,mid,tl,L,R)+ask1(mid+1,r,tr,L,R);
}
p ask2(int l,int r,int k,int L,int R)
{
    if(l>=L&&r<=R) return s[k];
    if(l>R||r<L) return (p){0};
    down(l,r,k);
    p LL=ask2(l,mid,tl,L,R),RR=ask2(mid+1,r,tr,L,R),ans;
    ans.sum=LL.sum+RR.sum;
    ans.Lw=max(LL.Lw,RR.Lw);
    ans.Lb=max(LL.Lb,RR.Lb);
    ans.llw=LL.llw,ans.rlw=RR.rlw;//
    ans.llb=LL.llb,ans.rlb=RR.rlb;//
    if(LL.llb==mid-l+1) ans.llb+=RR.llb;
    if(LL.llw==mid-l+1) ans.llw+=RR.llw;
    if(RR.rlb==r-mid) ans.rlb+=LL.rlb;
    if(RR.rlw==r-mid) ans.rlw+=LL.rlw;
    ans.Lw=max(ans.Lw,LL.rlw+RR.llw);
    ans.Lb=max(ans.Lb,LL.rlb+RR.llb);
    return ans;
}
int main()
{
    scanf("%d%d",&n,&m);
    build(1,n,1);
    for(int i=1;i<=m;i++)
      {
      	int op,a,b;
      	scanf("%d%d%d",&op,&a,&b);
      	a++,b++;
      	if(!op) change1(1,n,1,a,b);
      	else if(op==1) change2(1,n,1,a,b);
      	else if(op==2) change3(1,n,1,a,b);
      	else if(op==3) printf("%d\n",ask1(1,n,1,a,b));
      	else if(op==4) printf("%d\n",ask2(1,n,1,a,b).Lw);
      }
    return 0;
}
```
