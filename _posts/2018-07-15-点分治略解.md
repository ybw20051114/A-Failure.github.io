---
layout:     post
title:      "点分治略解"
date:       2018-07-15
author:     "DieSheep"
header-img: "img/used/79768.jpg"
catalog: true
tags:
    - 点分治
---
>我给你讲，[淀粉质](https://baike.baidu.com/item/%E6%B7%80%E7%B2%89%EF%BC%88%E8%B4%A8%EF%BC%89%E4%BD%93/19159395?fr=aladdin)可好吃了，真的

点分治，是一种处理树上路径问题的工具，举个例子：

>给定一棵树毁和一个整数k，求树上等于k的路径有多少条

做法很简单，枚举不同的两个点，然后dfs算出ta们间的距离，统计一下就行了

大概是O(n^3)的复杂度

布星啊n大一点就搞不了了

那找个根，求出每个点到根的距离，然后枚举两个点，求lca，简单加减一下就行了

大概是O(n^2*logn)的复杂度。。。？

还是布星啊n还要大，几万的数据就搞不了了~~怎么这么多事~~

考虑一下形成路径的情况，假设一条满足条件的路径经过点x，那么这条路径在x的一个子树里（以x为端点）或者在x的两个不同的子树里，如图：

![](/img/study/dianfenzhi.png) ![](/img/study/dianfenzhi2.png)

一个好的想法是找到一个根，然后dfs遍历ta子树中的每个点，依次处理每个点的子树答案

首先根不能随便选，选根不同会影下面遍历的效率的，如图：

![](/img/study/dianfenzhi3.png)

显然选y为根比选x为根不优，选x最多递归2层，选y最多递归4层

我们可以根据每个点子树大小确定根，当根的最大的子树最小时肯定是最优根

一个简单的树形dp就能搞定
```
void GET_ROOT(int x,int fa)//x为当前点，fa为父亲节点
{
    f[x]=0,siz[x]=1;//f表示这个点最大子树的大小，siz是这个点子树大小的和
    for(int i=h[x];i;i=c[i].x)//枚举儿子
      {
      	int y=c[i].y;
      	if(use[y]||y==fa) continue;//use表示之前遍历过了，这里没啥用
      	GET_ROOT(y,x);//往下遍历
      	f[x]=max(f[x],siz[y]);//更新f
      	siz[x]+=siz[y];
      }
    f[x]=max(f[x],Siz-siz[x]);//Siz表示在现在这棵子树中点的总数，开始时Siz=n，除了枚举的儿子所在的子树外，还有一棵子树是上面的那一堆，容斥原理
    if(f[x]<f[rt]) rt=x;//更新root
}
```
因为之后的分治过程还需要对子树单独找根，所以代码中有use，但是开始对整棵树无影响

找到根了，现在我们可以dfs一遍根的子树，求出根到子树各个点的距离

然后可以枚举子树里的两个点，如果两个点到根的距离和为k（题目要找距离为k的点对），那么答案+1

这是第二种情况，第一种情况就让距离根为k的点跟根配对就行了，因为根到根的距离为0
```
int look(int l,int x)//找左边界
{
	int ans=0,r=cnt;
	while(l<=r)
	{
		int mid(l+r>>1);
		if(d[mid]<x) l=mid+1;
		else ans=mid,r=mid-1;
	}
	return ans;
}
int look2(int l,int x)//找右边界
{
	int ans=0,r=cnt;
	while(l<=r)
	{
		int mid(l+r>>1);
		if(d[mid]<=x) ans=mid,l=mid+1;
		else r=mid-1;
	}
	return ans;
}
void GET_NUM(int x,int fa,int D)//求根到子树每个点的距离
{
	for(int i=h[x];i;i=c[i].x)
	  {
	  	int y=c[i].y;
	  	if(use[y]||y==fa) continue;
	  	d[++cnt]=D+c[i].dis;
	  	GET_NUM(y,x,d[cnt]);
	  }
}
int GET_ANS(int x)//求答案
{
	d[cnt=1]=0;
	GET_NUM(x,0,0);
	sort(d+1,d+1+cnt);//排下序
	int l=1,ans=0;
	while(l<cnt&&d[l]+d[cnt]<k) ++l;
	while(l<cnt&&k-d[l]>=d[l])
	{
		int D1(look(l+1,k-d[l])),D2(look2(l+1,k-d[l]));//枚举一个点，因为和是k，所以可以求出另一点到根的距离，二分一下就行了
		if(D2>=D1) ans+=D2-D1+1;
		++l;
	}
	return ans;
}
```
也可以通过移动两个指针来实现~~反正不是枚举两个点就行了~~

这样我们就快乐的A掉了这道题
![](/img/happy.jpg)

了吗？

求一遍发现答案不对诶。。。

